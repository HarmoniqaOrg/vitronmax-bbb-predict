/* SmilesStructure.tsx ----------------------------------------------------- */
import React, { useEffect, useRef, useState } from "react";

type Status = "loading" | "ok" | "error";

// Define interfaces for the RDKit module and molecule objects based on usage
interface RDKitMol {
  get_svg: (options?: { width?: number; height?: number; [key: string]: unknown }) => string;
  delete: () => void;
  // Add other RDKit Mol methods if they become necessary
}

interface RDKitModule {
  get_mol: (smiles: string, options?: unknown) => RDKitMol | null;
  // Add other RDKit module functions if they become necessary
}

let rdkitModule: RDKitModule | null = null;
const initRDKit = async () => {
  if (rdkitModule) return rdkitModule;
  // dynamic import so the wasm is only fetched client-side
  try {
    // Use 'any' for the dynamically imported module's type due to complex/unpredictable default export signature.
    // This is a pragmatic choice as precise typing for RDKit's dynamic Wasm import default can be challenging.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const RDKitEntry: any = await import('@rdkit/rdkit');
    
    if (typeof RDKitEntry.default === 'function') {
      // The 'rdkitModule' variable itself is typed with RDKitModule interface
      rdkitModule = await RDKitEntry.default(); 
      console.log("RDKit module initialized successfully via default().");
    } else {
      console.error("[SmilesStructure] RDKitEntry.default is not a function. Module structure:", RDKitEntry);
      throw new Error("RDKit's default export is not an initializer function.");
    }
  } catch (error) {
    console.error("Failed to initialize RDKit module:", error);
    throw error; // Re-throw to be caught by the caller in useEffect
  }
  return rdkitModule;
};

interface Props {
  smiles: string;
  width?: number;
  height?: number;
}

export const SmilesStructure: React.FC<Props> = ({
  smiles,
  width = 120,
  height = 90,
}) => {
  const divRef = useRef<HTMLDivElement | null>(null); // Ref for the div that will host the SVG string
  const [status, setStatus] = useState<Status>("loading");
  const [svgString, setSvgString] = useState<string>("");

  useEffect(() => {
    let cancelled = false;
    setStatus("loading");
    setSvgString(""); // Clear previous SVG string

    // console.log(`[SmilesStructure] useEffect for SMILES: ${smiles}, Width: ${width}, Height: ${height}`);

    initRDKit()
      .then((RDKit) => {
        if (cancelled) {
          // console.log("[SmilesStructure] Effect cancelled before drawing.");
          return;
        }
        if (!RDKit) {
          console.error("[SmilesStructure] RDKit module not available after init promise resolved.");
          if (!cancelled) setStatus("error");
          return;
        }

        // console.log(`[SmilesStructure] RDKit initialized, attempting to draw SMILES: ${smiles}`);
        try {
          const mol = RDKit.get_mol(smiles);
          if (!mol) {
            console.error(`[SmilesStructure] Failed to parse SMILES: ${smiles}. RDKit.get_mol returned null.`);
            throw new Error('Molecule could not be parsed from SMILES.');
          }
          // console.log(`[SmilesStructure] Molecule parsed for SMILES: ${smiles}. Generating SVG.`);
          const svg = mol.get_svg({ width, height });
          mol.delete(); // Important to free wasm memory
          
          if (!cancelled) {
            // console.log(`[SmilesStructure] SVG generated for SMILES: ${smiles}. Setting state.`);
            setSvgString(svg);
            setStatus("ok");
          }
        } catch (err) {
          console.error(`[SmilesStructure] RDKit-wasm draw error for SMILES: ${smiles}:`, err);
          if (!cancelled) setStatus("error");
        }
      })
      .catch((err) => {
        console.error(`[SmilesStructure] RDKit-wasm init error:`, err);
        if (!cancelled) setStatus("error");
      });

    return () => {
      // console.log(`[SmilesStructure] Cleanup effect for SMILES: ${smiles}`);
      cancelled = true;
    };
  }, [smiles, width, height]);

  return (
    <div
      style={{
        width,
        height,
        border:
          status === "error" ? "1px solid #ef4444" : "1px solid #e2e8f0", // Red border for error, light gray otherwise
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: status === "loading" ? "#f9fafb" : "transparent", // Light gray background for loading
        overflow: "hidden", // Prevent SVG from overflowing its container
      }}
    >
      {status === "loading" && (
        <span className="text-xs text-gray-400">Loadingâ€¦</span>
      )}
      {status === "error" && (
        <span className="text-xs text-red-500">Error</span> // Error text if drawing fails
      )}
      {/* Div to host the SVG generated by RDKit. It will be set via dangerouslySetInnerHTML */}
      {status === "ok" && svgString && (
        <div ref={divRef} dangerouslySetInnerHTML={{ __html: svgString }} />
      )}
    </div>
  );
};
